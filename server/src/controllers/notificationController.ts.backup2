import { Request, Response } from 'express';
import { pool } from '../config/database';

// Socket.IO ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë‚˜ì¤‘ì— ê°€ì ¸ì˜´ (ìˆœí™˜ ì°¸ì¡° ë°©ì§€)
let io: any;
setTimeout(() => {
  io = require('../app').io;
}, 0);

// ì•Œë¦¼ ìƒì„±
export const createNotification = async (req: Request, res: Response) => {
  try {
    console.log('[createNotification] Request body:', req.body);
    console.log('[createNotification] User:', (req as any).user);
    
    // ê´€ë¦¬ìž ê¶Œí•œ ì²´í¬
    const userRole = (req as any).user?.role;
    if (userRole !== 'operator') {
      return res.status(403).json({
        success: false,
        error: 'ê´€ë¦¬ìžë§Œ ì•Œë¦¼ì„ ë°œì†¡í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.'
      });
    }
    
    const {
      type,
      title,
      message,
      sender,
      recipientId,
      auto_close = true,
      duration = 5000,
      priority = 'normal',
      icon,
      metadata
    } = req.body;
    
    console.log('[createNotification] auto_close ê°’:', auto_close, typeof auto_close);
    console.log('[createNotification] ì „ì²´ body:', JSON.stringify(req.body));

    // recipientIdê°€ ë°°ì—´ì¸ ê²½ìš° (ì—¬ëŸ¬ ëª…ì—ê²Œ ë°œì†¡ - í•˜ë‚˜ì˜ ë ˆì½”ë“œë¡œ ì €ìž¥)
    if (Array.isArray(recipientId)) {
      console.log('[createNotification] Creating group notification for multiple users:', recipientId);
      
      try {
        // ê·¸ë£¹ ì•Œë¦¼ì„ í•˜ë‚˜ì˜ ë ˆì½”ë“œë¡œ ì €ìž¥ (metadataì— ì‹¤ì œ ìˆ˜ì‹ ìž ëª©ë¡ ì €ìž¥)
        const groupMetadata = {
          ...metadata,
          recipientType: 'group',
          recipientIds: recipientId,
          recipientCount: recipientId.length
        };
        
        const result = await pool.query(
          `INSERT INTO notifications 
           (type, title, message, sender, recipient_id, auto_close, duration, priority, icon, metadata)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
           RETURNING *`,
          [type, title, message, sender || 'operator', 'group', auto_close, duration, priority, icon, JSON.stringify(groupMetadata)]
        );
        
        const notification = result.rows[0];
        console.log('[createNotification] Group notification created:', notification);
        
        // ê° ì‚¬ìš©ìžì—ê²Œ ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡
        if (io) {
          for (const userId of recipientId) {
            io.to(`user_${userId}`).emit('new_notification', {
              ...notification,
              recipient_id: userId // ì‹¤ì‹œê°„ ì•Œë¦¼ì—ëŠ” ê°œë³„ ì‚¬ìš©ìž ID í¬í•¨
            });
            console.log(`ðŸ”” ì•Œë¦¼ì´ ì‚¬ìš©ìž ${userId}ì—ê²Œ ì‹¤ì‹œê°„ ì „ì†¡ë¨`);
          }
        }
        
        res.json({
          success: true,
          notification: notification,
          message: `${recipientId.length}ëª…ì˜ ì‚¬ìš©ìžì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
      } catch (queryError) {
        console.error('[createNotification] Query error:', queryError);
        throw queryError;
      }
    }
    // recipientIdê°€ 'all'ì¸ ê²½ìš° í•˜ë‚˜ì˜ ì•Œë¦¼ìœ¼ë¡œ ì €ìž¥
    else if (recipientId === 'all') {
      console.log('[createNotification] Creating notification for all users');
      
      try {
        // ì „ì²´ ì‚¬ìš©ìžìš© ì•Œë¦¼ì„ í•˜ë‚˜ì˜ ë ˆì½”ë“œë¡œ ì €ìž¥
        const result = await pool.query(
          `INSERT INTO notifications 
           (type, title, message, sender, recipient_id, auto_close, duration, priority, icon, metadata)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
           RETURNING *`,
          [type, title, message, sender || 'operator', 'all', auto_close, duration, priority, icon, metadata || null]
        );
        
        const notification = result.rows[0];
        console.log('[createNotification] Broadcast notification created:', notification);

        // ëª¨ë“  í™œì„± ì‚¬ìš©ìžì—ê²Œ ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡
        if (io) {
          // ëª¨ë“  ì‚¬ìš©ìž ì¡°íšŒí•˜ì—¬ ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡
          const usersResult = await pool.query(
            "SELECT id FROM users WHERE role != 'operator'",
            []
          );
          
          for (const user of usersResult.rows) {
            io.to(`user_${user.id}`).emit('new_notification', {
              ...notification,
              recipient_id: user.id // ì‹¤ì‹œê°„ ì•Œë¦¼ì—ëŠ” ì‚¬ìš©ìž ID í¬í•¨
            });
            console.log(`ðŸ”” ì•Œë¦¼ì´ ì‚¬ìš©ìž ${user.id}ì—ê²Œ ì‹¤ì‹œê°„ ì „ì†¡ë¨`);
          }
        } else {
          console.log(`âš ï¸ Socket.IOê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ`);
        }

        res.json({
          success: true,
          notification: notification,
          message: `ì „ì²´ ì‚¬ìš©ìžì—ê²Œ ì•Œë¦¼ì´ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
      } catch (queryError) {
        console.error('[createNotification] Query error:', queryError);
        throw queryError;
      }
    } else {
      // íŠ¹ì • ì‚¬ìš©ìžì—ê²Œë§Œ ì•Œë¦¼ ìƒì„±
      console.log('[createNotification] Creating notification for user:', recipientId);
      
      try {
        const result = await pool.query(
          `INSERT INTO notifications 
           (type, title, message, sender, recipient_id, auto_close, duration, priority, icon, metadata)
           VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
           RETURNING *`,
          [type, title, message, sender || 'operator', recipientId, auto_close, duration, priority, icon, metadata || null]
        );

        const notification = result.rows[0];
        console.log('[createNotification] Notification created:', notification);

        // ì‹¤ì‹œê°„ìœ¼ë¡œ í•´ë‹¹ ì‚¬ìš©ìžì—ê²Œ ì•Œë¦¼ ì „ì†¡
        if (io) {
          io.to(`user_${recipientId}`).emit('new_notification', notification);
          console.log(`ðŸ”” ì•Œë¦¼ì´ ì‚¬ìš©ìž ${recipientId}ì—ê²Œ ì‹¤ì‹œê°„ ì „ì†¡ë¨`);
        } else {
          console.log(`âš ï¸ Socket.IOê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ`);
        }

        res.json({
          success: true,
          notification: notification
        });
      } catch (queryError) {
        console.error('[createNotification] Query error:', queryError);
        throw queryError;
      }
    }
  } catch (error) {
    console.error('Create notification error:', error);
    res.status(500).json({
      success: false,
      error: 'ì•Œë¦¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ì‚¬ìš©ìžì˜ ì•Œë¦¼ ëª©ë¡ ì¡°íšŒ
export const getNotifications = async (req: Request, res: Response) => {
  try {
    console.log('[getNotifications] req.user:', (req as any).user);
    const userId = (req as any).user?.id;
    
    if (!userId) {
      console.log('[getNotifications] No user ID found');
      return res.status(401).json({
        success: false,
        error: 'ì¸ì¦ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.'
      });
    }
    
    console.log('[getNotifications] userId:', userId);
    const { type, isRead, limit = 50, offset = 0 } = req.query;

    // ìš´ì˜ìžëŠ” ì•Œë¦¼ì„ ë°›ì§€ ì•ŠìŒ
    const userRole = (req as any).user?.role;
    if (userRole === 'operator') {
      return res.json({
        success: true,
        notifications: []
      });
    }
    
    // ê°œì¸ ì•Œë¦¼ê³¼ ì „ì²´ ì•Œë¦¼ì„ ë³„ë„ë¡œ ì¡°íšŒí•´ì„œ í•©ì¹˜ê¸°
    // userIdë¥¼ ë¬¸ìžì—´ë¡œ ë³€í™˜
    const userIdStr = String(userId);
    
    let query = `
      SELECT n.*, 
             CASE 
               WHEN n.recipient_id = 'all' THEN nr.read_at
               ELSE n.read_at 
             END as read_at
      FROM notifications n
      LEFT JOIN notification_reads nr ON (n.id = nr.notification_id AND nr.user_id = $1::uuid AND n.recipient_id = 'all')
      WHERE (
        n.recipient_id = $2 
        OR n.recipient_id = 'all'
        OR (n.recipient_id = 'group' AND n.metadata::jsonb @> $3::jsonb)
      )
    `;
    const params: any[] = [userId, userIdStr, JSON.stringify({recipientIds: [userIdStr]})];

    if (type) {
      params.push(type);
      query += ` AND n.type = $${params.length}`;
    }

    if (isRead === 'true') {
      query += ` AND (
        (n.recipient_id NOT IN ('all', 'group') AND n.read_at IS NOT NULL) OR
        (n.recipient_id = 'all' AND nr.read_at IS NOT NULL)
      )`;
    } else if (isRead === 'false') {
      query += ` AND (
        (n.recipient_id NOT IN ('all', 'group') AND n.read_at IS NULL) OR
        (n.recipient_id = 'all' AND nr.read_at IS NULL)
      )`;
    }

    query += ` ORDER BY n.created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);

    const result = await pool.query(query, params);

    res.json({
      success: true,
      notifications: result.rows
    });
  } catch (error) {
    console.error('Get notifications error:', error);
    res.status(500).json({
      success: false,
      error: 'ì•Œë¦¼ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
export const markAsRead = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req as any).user.id;
    
    console.log(`[markAsRead] ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬ ì‹œë„ - ID: ${id}, User: ${userId}`);

    // ë¨¼ì € ì•Œë¦¼ì´ ì¡´ìž¬í•˜ëŠ”ì§€ í™•ì¸ (ìžì‹ ì˜ ì•Œë¦¼ ë˜ëŠ” ì „ì²´ ì•Œë¦¼)
    const userIdStr = String(userId);
    const checkResult = await pool.query(
      'SELECT * FROM notifications WHERE id = $1 AND (recipient_id = $2 OR recipient_id = \'all\')',
      [id, userIdStr]
    );
    
    if (checkResult.rows.length === 0) {
      console.log(`[markAsRead] ì•Œë¦¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ - ID: ${id}, User: ${userId}`);
      return res.status(404).json({
        success: false,
        error: 'ì•Œë¦¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }
    
    // ì´ë¯¸ ì½ì€ ì•Œë¦¼ì´ë©´ ê·¸ëŒ€ë¡œ ë°˜í™˜
    if (checkResult.rows[0].read_at) {
      console.log(`[markAsRead] ì´ë¯¸ ì½ì€ ì•Œë¦¼ - ID: ${id}`);
      return res.json({
        success: true,
        notification: checkResult.rows[0],
        message: 'ì´ë¯¸ ì½ì€ ì•Œë¦¼ìž…ë‹ˆë‹¤.'
      });
    }
    
    // ì „ì²´ ì•Œë¦¼ì¸ ê²½ìš°ì™€ ê°œì¸ ì•Œë¦¼ì¸ ê²½ìš°ë¥¼ êµ¬ë¶„í•˜ì—¬ ì²˜ë¦¬
    let result;
    const notification = checkResult.rows[0];
    
    if (notification.recipient_id === 'all') {
      // ì „ì²´ ì•Œë¦¼ì˜ ê²½ìš°: notification_reads í…Œì´ë¸”ì— ì½ìŒ ê¸°ë¡ ì¶”ê°€
      // ë¨¼ì € ì´ë¯¸ ì½ìŒ ê¸°ë¡ì´ ìžˆëŠ”ì§€ í™•ì¸
      const readCheckResult = await pool.query(
        'SELECT * FROM notification_reads WHERE notification_id = $1 AND user_id = $2',
        [id, userId]
      );
      
      if (readCheckResult.rows.length === 0) {
        // ì½ìŒ ê¸°ë¡ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ì¶”ê°€
        await pool.query(
          'INSERT INTO notification_reads (notification_id, user_id, read_at) VALUES ($1, $2, CURRENT_TIMESTAMP)',
          [id, userId]
        );
      }
      
      // ì›ë³¸ ì•Œë¦¼ ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ë˜ read_atì„ í˜„ìž¬ ì‹œê°„ìœ¼ë¡œ ì„¤ì •
      result = {
        rows: [{
          ...notification,
          read_at: new Date()
        }]
      };
    } else {
      // ê°œì¸ ì•Œë¦¼ì˜ ê²½ìš°: ê¸°ì¡´ ë°©ì‹ëŒ€ë¡œ notifications í…Œì´ë¸” ì§ì ‘ ì—…ë°ì´íŠ¸
      result = await pool.query(
        `UPDATE notifications 
         SET read_at = CURRENT_TIMESTAMP 
         WHERE id = $1 AND recipient_id = $2
         RETURNING *`,
        [id, userIdStr]
      );
    }
    
    console.log(`[markAsRead] ì½ìŒ ì²˜ë¦¬ ì™„ë£Œ:`, result.rows?.[0] || 'ì „ì²´ ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬');

    res.json({
      success: true,
      notification: result.rows[0]
    });
  } catch (error) {
    console.error('Mark as read error:', error);
    res.status(500).json({
      success: false,
      error: 'ì½ìŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
export const markAllAsRead = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const userIdStr = String(userId);

    // íŠ¸ëžœìž­ì…˜ ì‹œìž‘
    const client = await pool.connect();
    try {
      await client.query('BEGIN');
      
      // 1. ê°œì¸ ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
      const personalResult = await client.query(
        `UPDATE notifications 
         SET read_at = CURRENT_TIMESTAMP 
         WHERE recipient_id = $1 AND read_at IS NULL`,
        [userIdStr]
      );
      
      // 2. ì „ì²´ ì•Œë¦¼ì— ëŒ€í•œ ì½ìŒ ê¸°ë¡ ì¶”ê°€
      await client.query(
        `INSERT INTO notification_reads (notification_id, user_id, read_at)
         SELECT n.id, $1::uuid, CURRENT_TIMESTAMP
         FROM notifications n
         LEFT JOIN notification_reads nr ON (n.id = nr.notification_id AND nr.user_id = $1::uuid)
         WHERE n.recipient_id = 'all' AND nr.id IS NULL`,
        [userId]
      );
      
      await client.query('COMMIT');
      
      res.json({
        success: true,
        updated: personalResult.rowCount
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Mark all as read error:', error);
    res.status(500).json({
      success: false,
      error: 'ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ì•Œë¦¼ ì‚­ì œ
export const deleteNotification = async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const userId = (req as any).user.id;
    const userIdStr = String(userId);

    const result = await pool.query(
      'DELETE FROM notifications WHERE id = $1 AND recipient_id = $2',
      [id, userIdStr]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({
        success: false,
        error: 'ì•Œë¦¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    res.json({
      success: true,
      message: 'ì•Œë¦¼ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'
    });
  } catch (error) {
    console.error('Delete notification error:', error);
    res.status(500).json({
      success: false,
      error: 'ì•Œë¦¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ì¡°íšŒ
export const getUnreadCount = async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user.id;
    const userIdStr = String(userId);

    // ê°œì¸ ì•Œë¦¼ê³¼ ì „ì²´ ì•Œë¦¼ì„ ëª¨ë‘ ê³ ë ¤
    const result = await pool.query(
      `SELECT COUNT(*) as count
       FROM (
         SELECT n.id 
         FROM notifications n
         LEFT JOIN notification_reads nr ON (n.id = nr.notification_id AND nr.user_id = $1::uuid)
         WHERE (
           (n.recipient_id = $2 AND n.read_at IS NULL)
           OR (n.recipient_id = 'all' AND nr.read_at IS NULL)
         )
       ) AS unread_notifications`,
      [userId, userIdStr]
    );

    res.json({
      success: true,
      count: parseInt(result.rows[0].count)
    });
  } catch (error) {
    console.error('Get unread count error:', error);
    res.status(500).json({
      success: false,
      error: 'ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};

// ê´€ë¦¬ìžìš©: ëª¨ë“  ì•Œë¦¼ ë‚´ì—­ ì¡°íšŒ
export const getAllNotifications = async (req: Request, res: Response) => {
  try {
    const userRole = (req as any).user.role;
    
    // ê´€ë¦¬ìžë§Œ ì ‘ê·¼ ê°€ëŠ¥
    if (userRole !== 'operator') {
      return res.status(403).json({
        success: false,
        error: 'ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.'
      });
    }

    const { sender, type, fromDate, toDate, limit = 100, offset = 0 } = req.query;

    let query = `SELECT * FROM notifications WHERE 1=1`;
    const params: any[] = [];

    if (sender) {
      params.push(sender);
      query += ` AND sender = $${params.length}`;
    }

    if (type) {
      params.push(type);
      query += ` AND type = $${params.length}`;
    }

    if (fromDate) {
      params.push(fromDate);
      query += ` AND created_at >= $${params.length}`;
    }

    if (toDate) {
      params.push(toDate);
      query += ` AND created_at <= $${params.length}`;
    }

    query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);

    const result = await pool.query(query, params);

    res.json({
      success: true,
      notifications: result.rows
    });
  } catch (error) {
    console.error('Get all notifications error:', error);
    res.status(500).json({
      success: false,
      error: 'ì•Œë¦¼ ë‚´ì—­ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'
    });
  }
};